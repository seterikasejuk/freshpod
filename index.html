<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="manifest" href="manifest.json" />
  <meta name="theme-color" content="#ffffff" />
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" type="image/png" href="icon.png" />
  <title>üéß FreshPod+ A FishRadio</title>
  <style>
    body {
      font-family: sans-serif;
      background: #f9f9f9;
      padding: 1rem;
    }
    input, button, textarea {
      display: block;
      margin: 1rem 0;
      padding: 0.5rem;
      width: 100%;
    }
    audio {
      width: 100%;
      margin-top: 1rem;
    }
    .played {
      text-decoration: line-through;
      opacity: 0.6;
    }
    .ticker {
      font-size: 1.2em;
      margin-bottom: 1rem;
    }
  </style>
</head>
<body>
  <h1>üéß FreshPod+ A FishRadio üê†</h1>

  <h3>Upload Podcast Episodes</h3>
  <input type="file" id="episodeUpload" accept="audio/mpeg" multiple />

  <h3>Upload Local Breaks</h3>
  <input type="file" id="breakUpload" accept="audio/mpeg" multiple />

  <h3>Add Podcast RSS Feeds</h3>
  <textarea id="rssFeeds" rows="4" placeholder="Enter one RSS feed per line..."></textarea>
  <button onclick="fetchFeeds()">üì° Fetch Episodes</button>

  <div class="ticker" id="breakTicker">‚è±Ô∏è Next break in: --:--</div>

<h3>Set Break Interval (minutes)</h3>
<input type="number" id="breakMinutes" min="1" value="10" />
<button onclick="updateBreakInterval()">‚è±Ô∏è Set Break Timer</button>

  <h3>Episode Playlist</h3>
  <ul id="playlist"></ul>
  <button onclick="shuffleAndPlay()">‚ñ∂Ô∏è Shuffle & Play</button>

  <audio id="player" controls></audio>

  <script>
    let episodeList = JSON.parse(localStorage.getItem("episodeList")) || [];
    let breakList = []; // can't persist breaks
    let playedEpisodes = new Set(JSON.parse(localStorage.getItem("playedEpisodes")) || []);
    let breakCountdown;
    let breakInterval = 10 * 60; // default 10 minutes
    let breakTimer;
    let currentEpisodeIndex = parseInt(localStorage.getItem("currentEpisodeIndex")) || 0;
    let isInBreak = false;
    let resumeTime = 0;

    const player = document.getElementById("player");
    const playlistUI = document.getElementById("playlist");
    const ticker = document.getElementById("breakTicker");
    const rssFeedsTextarea = document.getElementById("rssFeeds");

    // Restore RSS feeds
    rssFeedsTextarea.value = localStorage.getItem("rssFeeds") || "";

    function saveState() {
      localStorage.setItem("episodeList", JSON.stringify(episodeList));
      localStorage.setItem("playedEpisodes", JSON.stringify([...playedEpisodes]));
      localStorage.setItem("currentEpisodeIndex", currentEpisodeIndex);
    }

function renderPlaylist() {
  playlistUI.innerHTML = "";

episodeList.forEach((ep, idx) => {
  const li = document.createElement("li");
  li.textContent = ep.title;
  li.className = playedEpisodes.has(ep.title) ? "played" : "";
  li.draggable = true;
  li.dataset.index = idx;

  li.addEventListener("dragstart", (e) => {
    e.dataTransfer.setData("text/plain", idx);
  });

  li.addEventListener("dragover", (e) => {
    e.preventDefault();
    li.style.border = "2px dashed #aaa";
  });

  li.addEventListener("dragleave", () => {
    li.style.border = "";
  });

  li.addEventListener("drop", (e) => {
    e.preventDefault();
    li.style.border = "";
    const from = parseInt(e.dataTransfer.getData("text/plain"));
    const to = parseInt(li.dataset.index);
    moveEpisode(from, to);
  });

  li.onclick = () => playEpisode(idx);
  playlistUI.appendChild(li);
});
}

function setupEventListeners() {
    document.getElementById("episodeUpload").addEventListener("change", (e) => {
      const files = Array.from(e.target.files);
      files.forEach(f => {
        episodeList.push({ title: f.name, src: URL.createObjectURL(f), type: 'local' });
      });
      renderPlaylist();
      saveState();
    });

    let hasAlertedBreakUpload = false;

    document.getElementById("breakUpload").addEventListener("change", (e) => {
      breakList = Array.from(e.target.files).map(f => URL.createObjectURL(f));
      if (!hasAlertedBreakUpload) {
      alert(`Uploaded ${breakList.length} break file(s).`);
      hasAlertedBreakUpload = true;
      setTimeout(() => hasAlertedBreakUpload = false, 3000);
    }
    });
}

function moveEpisode(fromIndex, toIndex) {
  const moved = episodeList.splice(fromIndex, 1)[0];
  episodeList.splice(toIndex, 0, moved);
  renderPlaylist();
  saveState();
}

function fetchFeeds() {
  const feeds = document.getElementById("rssFeeds").value
    .split("\n")
    .map(f => f.trim())
    .filter(Boolean);

  const skipPlayed = true; // make this a toggle later if you want

feeds.forEach(feedUrl => {
  fetch(`https://0ec86150-a560-4df1-91f9-1e02a6763c87-00-3t5goonczztrn.sisko.replit.dev/rss?url=${encodeURIComponent(feedUrl)}`)
    .then(res => res.json())
    .then(data => {
      console.log("Fetched data:", data);

      if (!data.items || !Array.isArray(data.items)) {
        alert("This feed returned no items: " + feedUrl);
        return;
      }

      data.items
        .filter(item => {
          const audioUrl = item.audio || item.enclosure?.url || item.enclosure?.link || item.link;
          return audioUrl && audioUrl.endsWith(".mp3");
        })
        .filter(item => !playedEpisodes.has(item.title))
        .slice(0, 5)
        .forEach(item => {
          const audioUrl = item.audio || item.enclosure?.url || item.enclosure?.link || item.link;
          episodeList.push({
            title: item.title,
            src: audioUrl,
            type: "feed",
          });
        });

      renderPlaylist();
      saveState();
    })
    .catch(err => {
      console.error("RSS fetch failed:", err);
      alert("Failed to load RSS feed: " + feedUrl);
    });
});

}


    function shuffleAndPlay() {
  const unplayed = episodeList.filter(ep => !playedEpisodes.has(ep.title));
  if (unplayed.length === 0) {
    alert("üéâ You've played all episodes!");
    return;
  }

      episodeList = episodeList.sort(() => Math.random() - 0.5);
      currentEpisodeIndex = 0;
      playEpisode(currentEpisodeIndex);
      startBreakTicker();
      player.play().catch(() => {
        alert("Tap anywhere to start playback due to mobile browser restrictions.");
      });
      saveState();
    }

    function playEpisode(index) {
      if (!episodeList[index]) return;
      currentEpisodeIndex = index;
      player.src = episodeList[index].src;
      player.play();
      saveState();
    }

player.addEventListener("ended", () => {
  if (isInBreak) {
    isInBreak = false;

    ticker.textContent = `‚è±Ô∏è Next break in: ${formatTime(breakInterval)}`; // Reset timer text

    // Add fade + resume logic AFTER episode loads
    player.addEventListener("loadedmetadata", function resumeWithFadeOnce() {
      player.currentTime = resumeTime;
      fadeInAudio(player);
      player.removeEventListener("loadedmetadata", resumeWithFadeOnce);
    });

    playEpisode(currentEpisodeIndex); // üîÑ this should come AFTER adding the listener

    startBreakTicker();

  } else {
    playedEpisodes.add(episodeList[currentEpisodeIndex].title);
    currentEpisodeIndex++;
    if (currentEpisodeIndex < episodeList.length) {
      playEpisode(currentEpisodeIndex);
    }
    renderPlaylist();
    saveState();
  }
});

function updateBreakInterval() {
  const minutes = parseInt(document.getElementById("breakMinutes").value);
  if (!isNaN(minutes) && minutes > 0) {
    breakInterval = minutes * 60;
    breakCountdown = breakInterval;
    ticker.textContent = `‚è±Ô∏è Next break in: ${formatTime(breakCountdown)}`;
    startBreakTicker(); // restart ticker
  }
}

    function startBreakTicker() {
      clearInterval(breakTimer);
      breakCountdown = breakInterval;
      ticker.textContent = `‚è±Ô∏è Next break in: ${formatTime(breakCountdown)}`;
      breakTimer = setInterval(() => {
        breakCountdown--;
        ticker.textContent = `‚è±Ô∏è Next break in: ${formatTime(breakCountdown)}`;
        if (breakCountdown <= 0) {
          playBreak();
          breakCountdown = breakInterval;
        }
      }, 1000);
    }

function fadeOutAudio(audio, callback, step = 0.05, interval = 100) {
  let fade = setInterval(() => {
    if (audio.volume > step) {
      audio.volume -= step;
    } else {
      clearInterval(fade);
      audio.volume = 0;
      callback(); // e.g. playBreak()
    }
  }, interval);
}

function fadeInAudio(audio, targetVolume = 1, step = 0.05, interval = 100) {
  audio.volume = 0;
  let fade = setInterval(() => {
    if (audio.volume < targetVolume - step) {
      audio.volume += step;
    } else {
      audio.volume = targetVolume;
      clearInterval(fade);
    }
  }, interval);
}


    function playBreak() {
      if (!breakList.length) return;
      resumeTime = player.currentTime;
      isInBreak = true;

      clearInterval(breakTimer);
      ticker.textContent = `üéµ Taking a break... relaxing fish sounds...`;

      const randomBreak = breakList[Math.floor(Math.random() * breakList.length)];

    fadeOutAudio(player, () => {
      player.src = randomBreak;
      player.play();
      fadeInAudio(player);
    });
    }

    function formatTime(seconds) {
      const min = Math.floor(seconds / 60).toString().padStart(2, '0');
      const sec = (seconds % 60).toString().padStart(2, '0');
      return `${min}:${sec}`;
    }

    // On page load
    renderPlaylist();
    startBreakTicker();

  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js')
      .then(() => console.log("‚úÖ FreshPod+ Service Worker registered"));
  }

  </script>
</body>
</html>
