<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Multi-Feed Podcast Player</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
      background: #f5f5f5;
    }
    input, button, select, textarea {
      padding: 8px;
      margin-bottom: 10px;
      width: 100%;
    }
    ul {
      list-style: none;
      padding: 0;
    }
    li {
      background: #fff;
      margin: 5px 0;
      padding: 10px;
      border-radius: 4px;
      cursor: move;
    }
    li.played {
      background-color: #d3d3d3;
      text-decoration: line-through;
    }
    #countdown {
      font-weight: bold;
      margin-top: 10px;
      font-size: 1.1em;
    }
    #toast {
      visibility: hidden;
      min-width: 250px;
      margin-left: -125px;
      background-color: #333;
      color: #fff;
      text-align: center;
      border-radius: 2px;
      padding: 12px;
      position: fixed;
      z-index: 1;
      left: 50%;
      bottom: 30px;
      font-size: 16px;
    }
    #toast.show {
      visibility: visible;
      -webkit-animation: fadein 0.5s, fadeout 0.5s 2.5s;
      animation: fadein 0.5s, fadeout 0.5s 2.5s;
    }
    @keyframes fadein {
      from {bottom: 0; opacity: 0;}
      to {bottom: 30px; opacity: 1;}
    }
    @keyframes fadeout {
      from {bottom: 30px; opacity: 1;}
      to {bottom: 0; opacity: 0;}
    }
  </style>
</head>
<body>
  <h2>üéß Multi-Feed Podcast Player + Tracker + Breaks + Drag & Drop</h2>
  <textarea id="rssInput" placeholder="Paste multiple podcast RSS feeds here (one per line)"></textarea>
  <button onclick="loadMultipleFeeds()">Load All Feeds</button>
  <button onclick="shuffleEpisodes()">üîÄ Shuffle</button>
  <button onclick="clearHistory()">üßπ Clear Listening History</button>
  <button onclick="exportHistory()">üíæ Export Listening History</button>
  <input type="file" id="importFile" accept="application/json" onchange="importHistory(event)" />

  <label for="intervalSelect">Break Interval:</label>
  <select id="intervalSelect" onchange="updateBreakInterval()">
    <option value="10">Every 10 minutes</option>
    <option value="15">Every 15 minutes</option>
    <option value="20" selected>Every 20 minutes</option>
    <option value="30">Every 30 minutes</option>
    <option value="60">Every 60 minutes</option>
  </select>

  <input type="file" id="breakUpload" accept="audio/mpeg" multiple />

  <div id="countdown">‚è±Ô∏è Break in: --:--</div>
  <div id="toast"></div>

  <ul id="episodeList"></ul>

  <audio id="player" controls style="width: 100%; margin-top: 20px; transition: opacity 1s;"></audio>

  <script>
    let breakInterval = 20 * 60 * 1000;
    const breakFeeds = [
      "https://www.omnycontent.com/d/playlist/9c074afa-3313-47e8-b802-a9f900789975/63048eda-2427-408a-b47c-ad5001293fca/6677d422-fd43-4aaa-be74-ad5001293fd8/podcast.rss",
      "https://anchor.fm/s/d3f9488/podcast/rss",
      "https://anchor.fm/s/2d2a1fe8/podcast/rss",
      "https://anchor.fm/s/13f65d84/podcast/rss",
      "https://rss.art19.com/curiosity-daily",
      "https://feeds.npr.org/500005/podcast.xml"
    ];
    const defaultBreakAudio = "https://server13.mp3quran.net/husr/112.mp3";

    const player = document.getElementById("player");
    const countdownDisplay = document.getElementById("countdown");
    const toast = document.getElementById("toast");
    let timer;
    let countdownInterval;
    let currentEpisodeURL = "";
    let remainingMs = breakInterval;
    let episodeList = [];
    let currentIndex = -1;
    let skipBreak = false;
    let customBreaks = [];

    document.getElementById("breakUpload").addEventListener("change", event => {
      const files = Array.from(event.target.files).filter(file => file.type === "audio/mpeg");
      if (files.length > 0) {
        customBreaks = files.map(file => URL.createObjectURL(file));
        showToast(`üéß Uploaded ${customBreaks.length} custom break(s)!`);
      }
    });

    function showToast(message) {
      toast.textContent = message;
      toast.className = "show";
      setTimeout(() => {
        toast.className = toast.className.replace("show", "");
      }, 3000);
    }

    function clearHistory() {
      localStorage.clear();
      showToast("üßπ Listening history cleared");
      renderEpisodeList();
    }

    function exportHistory() {
      const history = {};
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        history[key] = localStorage.getItem(key);
      }
      const blob = new Blob([JSON.stringify(history, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "listening_history.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function importHistory(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        try {
          const data = JSON.parse(e.target.result);
          for (const key in data) {
            localStorage.setItem(key, data[key]);
          }
          showToast("‚úÖ History imported!");
          renderEpisodeList();
        } catch (err) {
          showToast("‚ùå Invalid file");
        }
      };
      reader.readAsText(file);
    }

    function loadMultipleFeeds() {
      const input = document.getElementById("rssInput").value;
      const urls = input.split(/\n|,/).map(url => url.trim()).filter(Boolean);
      episodeList = [];
      document.getElementById("episodeList").innerHTML = "";

      Promise.all(urls.map(url => {
        const apiUrl = `https://api.rss2json.com/v1/api.json?rss_url=${encodeURIComponent(feedUrl)}&api_key=b1de5hx8lkootynqrn1v7dn34c555cbza5km9f01`;
        return fetch(apiUrl).then(res => res.json()).catch(() => null);
      })).then(results => {
        results.forEach(data => {
          if (!data || !data.items) return;
          const source = data.feed.title;
          data.items.slice(0, 10).forEach(item => {
            item.source = source;
            episodeList.push(item);
          });
        });

        renderEpisodeList();
      });
    }

    function renderEpisodeList() {
      const list = document.getElementById("episodeList");
      list.innerHTML = "";
      episodeList.forEach((episode, index) => {
        const li = document.createElement("li");
        li.textContent = `${episode.title} (${episode.source})`;
        li.draggable = true;
        li.dataset.index = index;
        const key = episode.enclosure.link;
        if (localStorage.getItem(key + "_played")) {
          li.classList.add("played");
        }
        li.ondragstart = e => e.dataTransfer.setData("text/plain", index);
        li.ondragover = e => e.preventDefault();
        li.ondrop = e => {
          e.preventDefault();
          const fromIndex = +e.dataTransfer.getData("text/plain");
          const toIndex = +li.dataset.index;
          [episodeList[fromIndex], episodeList[toIndex]] = [episodeList[toIndex], episodeList[fromIndex]];
          renderEpisodeList();
        };
        li.onclick = () => playEpisode(episode.enclosure.link, index);
        list.appendChild(li);
      });
    }

    function shuffleEpisodes() {
      for (let i = episodeList.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [episodeList[i], episodeList[j]] = [episodeList[j], episodeList[i]];
      }
      renderEpisodeList();
    }

    function playEpisode(url, index) {
      currentIndex = index;
      currentEpisodeURL = url;
      const resumeTime = parseFloat(localStorage.getItem(url + "_time")) || 0;
      player.src = url;
      player.onloadedmetadata = () => {
        player.currentTime = resumeTime;
        player.play();
      };
      skipBreak = false;
      resetBreakTimer();

      player.onended = () => {
        skipBreak = true;
        localStorage.setItem(url + "_played", true);
        renderEpisodeList();
        if (currentIndex + 1 < episodeList.length) {
          const nextEp = episodeList[currentIndex + 1];
          playEpisode(nextEp.enclosure.link, currentIndex + 1);
        } else {
          showToast("üéâ You've reached the end of the playlist!");
        }
      };
    }

    setInterval(() => {
      if (!player.paused && currentEpisodeURL) {
        localStorage.setItem(currentEpisodeURL + "_time", player.currentTime);
      }
    }, 5000);

    function resetBreakTimer() {
      if (timer) clearTimeout(timer);
      if (countdownInterval) clearInterval(countdownInterval);

      remainingMs = breakInterval;
      updateCountdown();
      countdownInterval = setInterval(() => {
        remainingMs -= 1000;
        updateCountdown();
        if (remainingMs <= 0) clearInterval(countdownInterval);
      }, 1000);

      timer = setTimeout(() => {
        if (!skipBreak) insertBreakEpisode();
      }, breakInterval);
    }

    function insertBreakEpisode() {
      const resumeURL = currentEpisodeURL;
      const resumeTime = player.currentTime;

      const playResume = () => {
        player.style.opacity = 1;
        player.src = resumeURL;
        player.onloadedmetadata = () => {
          player.currentTime = resumeTime;
          player.play();
          resetBreakTimer();
        };
      };

      player.pause();
      player.style.opacity = 0.3;

      if (customBreaks.length > 0) {
        const breakSrc = customBreaks[Math.floor(Math.random() * customBreaks.length)];
        player.src = breakSrc;
        player.play();
        player.onended = playResume;
        return;
      }

      const feedURL = breakFeeds[Math.floor(Math.random() * breakFeeds.length)];
      const apiUrl = `https://api.rss2json.com/v1/api.json?rss_url=${encodeURIComponent(feedUrl)}&api_key=b1de5hx8lkootynqrn1v7dn34c555cbza5km9f01`;

      fetch(apiUrl)
        .then(res => res.json())
        .then(data => {
          const episodes = data.items.filter(item => item.enclosure && item.enclosure.link.endsWith('.mp3'));
          const breakAudio = episodes.length > 0 ? episodes[Math.floor(Math.random() * episodes.length)].enclosure.link : defaultBreakAudio;
          player.src = breakAudio;
          player.play();
          player.onended = playResume;
        })
        .catch(() => {
          player.src = defaultBreakAudio;
          player.play();
          player.onended = playResume;
        });
    }


    function updateBreakInterval() {
      const minutes = parseInt(document.getElementById("intervalSelect").value);
      breakInterval = minutes * 60 * 1000;
      resetBreakTimer();
    }

    function updateCountdown() {
      const mins = Math.floor(remainingMs / 60000);
      const secs = Math.floor((remainingMs % 60000) / 1000);
      countdownDisplay.textContent = `‚è±Ô∏è Break in: ${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    }
  </script>
</body>
</html>
